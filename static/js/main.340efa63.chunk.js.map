{"version":3,"sources":["js/constants/index.ts","js/utils/board.ts","js/components/Tile.tsx","js/actions/index.ts","js/utils/dimensions.ts","js/components/Board.tsx","js/components/Timer.tsx","js/utils/timer.ts","js/utils/tiles.ts","js/components/Tally.tsx","js/components/Splash.tsx","js/components/Popup.tsx","js/components/Game.tsx","js/reducer/index.ts","js/components/App.tsx","index.tsx"],"names":["ACTIONS","SEED","INDEX","COLUMNS","ROWS","UNDERLINED","SPLASHES","randomInt","random","max","Math","floor","nextSeed","result","i","length","newBoard","seed","lowerSeed","toLowerCase","seedrandom","alea","sequence","array","Array","from","BOARD_DIMENSIONS","keys","j","getDieSequence","board","seqIndex","currentDies","dies","dieFace","isWordAllowed","word","existingWords","includes","isTileAdjacent","last","current","id","split","lastColumn","lastRow","currentColumn","currentRow","lastColumnIndex","indexOf","lastRowIndex","currentColumnIndex","currentRowIndex","allowedColumn","abs","allowedRow","isBackTrack","selection","wasPreviouslySelected","map","x","DieFace","styled","div","inPlay","selected","size","Text","underline","mapDispatchToProps","tileSelect","tile","type","Tile","connect","coord","selecting","currentTiles","value","textRef","createRef","useEffect","el","inColumn","offsetLeft","offsetWidth","inRow","offsetTop","y","offsetHeight","inCurrentTile","ref","getWindowDimensions","window","width","innerWidth","height","innerHeight","PlayTiles","FixedTiles","TileRow","onTouchMove","e","touches","clientX","clientY","onTouchEnd","setNextSeed","Board","stateSeed","seedParam","URLSearchParams","location","search","get","useState","windowDimensions","setWindowDimensions","handleResize","addEventListener","removeEventListener","useWindowDimensions","Tiles","row","rIndex","key","index","column","getId","StyledTimer","timerEnd","Timer","seconds","setSeconds","interval","setInterval","clearInterval","display","s","padStart","parseTimerProps","tilesToString","t","join","peek","Container","StyledWords","ol","StyledWord","li","cancelled","Button","button","newGame","Tally","words","initState","sort","a","b","localeCompare","actualWords","setActualWords","scoreVisible","setScoreVisible","total","filter","score","reduce","onClick","newWords","toggle","style","marginTop","tallyText","autoFocus","StyledSplash","startGame","Splash","text","setText","StyledContainer","StyledPopup","span","show","Popup","latestWord","setShow","setDisplay","GameCenter","Game","displaySplash","marginBottom","initialState","store","createStore","state","action","pop","push","searchParams","set","toString","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.340efa63.chunk.js","sourcesContent":["export const ACTIONS = {\n  TOUCH_START: 'TOUCH_START',\n  TOUCH_END: 'TOUCH_END',\n  TILE_SELECT: 'TILE_SELECT',\n  TIME_END: 'TIME_END',\n  NEW_GAME: 'NEW_GAME',\n  SET_NEXT_SEED: 'SET_NEXT_SEED',\n  START_GAME: 'START_GAME',\n};\n\nexport const BOARD_DIMENSIONS = 4;\n\nexport const DOWN_SCALE = 0.4;\n\nexport const GAME_TIME = 5;\n\nexport const SEED = {\n  SIZE: 4,\n  BASE: '0123456789abcdefghijklmnopqrstuvwxyz',\n};\n\n// Using excel/sheets style\nexport const INDEX = {\n  COLUMNS: ['a', 'b', 'c', 'd'],\n  ROWS: ['1', '2', '3', '4'],\n};\n\nexport const UNDERLINED = ['N', 'M', 'W', 'Z'];\n\nexport const SPLASHES = {\n  READY: 'Ready?',\n  STEADY: 'Steady ...',\n  GO: 'GO!',\n};\n","import seedrandom from 'seedrandom';\nimport { dies } from './../data/dies.json';\nimport { BOARD_DIMENSIONS, SEED, INDEX } from '../constants';\nimport { TileType } from '../types';\n\ntype DIES = {\n  [key: string]: string[][];\n};\n\n// Returns a random sequence of dies to process\nconst getDieSequence = (random: seedrandom.prng): Array<number> => {\n  // create array populated with numbers 0- DIM*DIM\n  let array = Array.from(Array(BOARD_DIMENSIONS * BOARD_DIMENSIONS).keys());\n  // https://javascript.info/task/shuffle\n  // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = randomInt(random, i + 1);\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n};\n\n// Returns a random number up to specified max\nconst randomInt = (random: seedrandom.prng, max: number): number => {\n  return Math.floor(random() * max);\n};\n\n// Get the next seed (for sharing)\nconst nextSeed = (random: seedrandom.prng): string => {\n  let result = '';\n  for (let i = 0; i < SEED.SIZE; i++) {\n    result += SEED.BASE[randomInt(random, SEED.BASE.length)];\n  }\n  return result;\n};\n\n// Orchestrates creation of random generator and the board\n// Also create the next seed based on the current one\nexport const newBoard = (seed: string) => {\n  const lowerSeed = seed.toLowerCase();\n\n  // https://github.com/davidbau/seedrandom\n  const random = seedrandom.alea(lowerSeed);\n\n  const sequence = getDieSequence(random);\n\n  let board: string[][] = [];\n  let seqIndex = 0;\n\n  const currentDies = (dies as DIES)[`dies${BOARD_DIMENSIONS}`];\n\n  // Populate the 4x4 board sequentially\n  for (var i = 0; i < BOARD_DIMENSIONS; i++) {\n    board[i] = [];\n    for (var j = 0; j < BOARD_DIMENSIONS; j++) {\n      const index = sequence[seqIndex++];\n      const die = currentDies[index];\n      const dieFaceIndex = randomInt(random, 6);\n      const dieFace = die[dieFaceIndex];\n      board[i][j] = dieFace;\n    }\n  }\n  return { board, nextSeed: nextSeed(random) };\n};\n\n// Get the score for the given word\nexport const score = (word: string): number => {\n  switch (word.length) {\n    case 3:\n    case 4:\n      return 1;\n    case 5:\n      return 2;\n    case 6:\n      return 3;\n    case 7:\n      return 5;\n    default:\n      return 11;\n  }\n};\n\nexport const isWordAllowed = (word: string, existingWords: string[]): boolean => {\n  if (word.length < 3 || existingWords.includes(word)) {\n    // Two letter words not allowed\n    // Repeated words not allowed\n    return false;\n  } else {\n    // Word allowed\n    return true;\n  }\n};\n\n// Check to see if the current tile is adjacent to the last one\n// Is there a better looking way to do this?\nexport const isTileAdjacent = (last: TileType, current: TileType): boolean => {\n  const [lastColumn, lastRow] = last.id.split('');\n  const [currentColumn, currentRow] = current.id.split('');\n\n  const lastColumnIndex = INDEX.COLUMNS.indexOf(lastColumn);\n  const lastRowIndex = INDEX.ROWS.indexOf(lastRow);\n\n  const currentColumnIndex = INDEX.COLUMNS.indexOf(currentColumn);\n  const currentRowIndex = INDEX.ROWS.indexOf(currentRow);\n\n  const allowedColumn = Math.abs(lastColumnIndex - currentColumnIndex) <= 1;\n  const allowedRow = Math.abs(lastRowIndex - currentRowIndex) <= 1;\n  return allowedColumn && allowedRow;\n};\n\n// I moved this here so that only one file understands how the construct/deconstruct the key/id\nexport const getId = (column: number, row: number): string => {\n  return INDEX.COLUMNS[column] + INDEX.ROWS[row];\n};\n\n// Is the current tile the one before the latest one\n// This will allow users to back track words\nexport const isBackTrack = (selection: Array<TileType>, current: TileType): boolean => {\n  if (selection.length > 1) {\n    // Has at least two elements\n    const previous = selection[selection.length - 2];\n    return previous.id === current.id;\n  } else {\n    return false;\n  }\n};\n\n// Was the tile previously selected\nexport const wasPreviouslySelected = (selection: Array<TileType>, current: TileType): boolean => {\n  return selection.map((x) => x.id).includes(current.id);\n};\n","import React, { createRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { connect } from 'react-redux';\n\nimport { onTileSelectAction } from '../actions';\nimport { TileType } from '../types';\nimport { UNDERLINED, DOWN_SCALE } from '../constants';\n\nconst DieFace = styled.div<{ selected: boolean; inPlay: boolean; size: number }>`\n  box-sizing: border-box;\n  text-align: center;\n  vertical-align: middle;\n  display: table-cell;\n  border: 1px solid black;\n  border-radius: ${({ inPlay }) => (inPlay ? 20 : 20 * DOWN_SCALE)}px;\n  background-color: ${({ selected }) => (selected ? 'yellow' : 'white')};\n  width: ${({ inPlay, size }) => (inPlay ? size : size * DOWN_SCALE)}px;\n  height: ${({ inPlay, size }) => (inPlay ? size : size * DOWN_SCALE)}px;\n`;\n\nconst Text = styled.div<{ inPlay: boolean; size: number; underline: boolean }>`\n  margin: 0 auto;\n  width: 75%;\n  height: 75%;\n  font-size: ${({ inPlay, size }) => (inPlay ? size - 50 : (size - 50) * DOWN_SCALE)}px;\n  text-decoration: ${({ underline }) => (underline ? 'underline' : 'none')};\n`;\n\ninterface TileInterface {\n  tile: TileType; // passed down\n  size: number; // passed down\n  coord: {\n    // redux state\n    x: number;\n    y: number;\n  };\n  selecting: boolean; // redux state\n  currentTiles: Array<TileType>; // redux state\n  inPlay: boolean; // redux state\n  tileSelect: (tile: TileType) => { type: string; current: TileType }; // redux dispatch\n}\n\n// Check if the touch is over the current tile\nconst inCurrentTile = (el: HTMLDivElement, coord: { x: number; y: number }): boolean => {\n  let inColumn = el.offsetLeft < coord.x && coord.x < el.offsetLeft + el.offsetWidth;\n  let inRow = el.offsetTop < coord.y && coord.y < el.offsetTop + el.offsetHeight;\n  return inColumn && inRow;\n};\n\nconst TileComponent = ({ tile, size, coord, selecting, currentTiles, inPlay, tileSelect }: TileInterface) => {\n  const underline = UNDERLINED.includes(tile.value);\n\n  // useful for getting co-ordinates of the selection area (Text)\n  const textRef = createRef<HTMLDivElement>();\n\n  const selected = inPlay ? currentTiles.map((x) => x.id).includes(tile.id) : false;\n\n  useEffect(() => {\n    const el = textRef.current;\n    // If user is still selecting and the touch is over the tile\n    if (selecting && el && inCurrentTile(el, coord)) {\n      tileSelect(tile);\n    }\n  }, [coord, selecting, tile, tileSelect, textRef]);\n  return (\n    <DieFace size={size} selected={selected} inPlay={inPlay}>\n      <Text ref={textRef} size={size} underline={underline} inPlay={inPlay}>\n        {tile.value}\n      </Text>\n    </DieFace>\n  );\n};\nconst mapStateToProps = ({\n  coord,\n  selecting,\n  currentTiles,\n  inPlay,\n}: {\n  coord: {\n    x: number;\n    y: number;\n  };\n  selecting: boolean;\n  currentTiles: Array<TileType>;\n  inPlay: boolean;\n}) => ({\n  coord,\n  selecting,\n  currentTiles,\n  inPlay,\n});\n\nconst mapDispatchToProps = { tileSelect: onTileSelectAction };\n\nexport const Tile = connect(mapStateToProps, mapDispatchToProps)(TileComponent);\n","import React from 'react';\nimport { ACTIONS } from '../constants';\nimport { TileType } from '../types';\n\nexport const onTouchMoveAction = (e: React.TouchEvent<HTMLDivElement>) => ({\n  type: ACTIONS.TOUCH_START,\n  coord: { x: e.touches[0].clientX, y: e.touches[0].clientY },\n});\n\nexport const onTouchEndAction = () => ({\n  type: ACTIONS.TOUCH_END,\n});\n\nexport const onTileSelectAction = (tile: TileType) => ({\n  type: ACTIONS.TILE_SELECT,\n  current: tile,\n});\n\nexport const onTimerEndedAction = () => ({\n  type: ACTIONS.TIME_END,\n});\n\nexport const newGameAction = () => ({\n  type: ACTIONS.NEW_GAME,\n});\n\nexport const setNextSeedAction = (seed: string) => ({\n  type: ACTIONS.SET_NEXT_SEED,\n  seed,\n});\n\nexport const startGameAction = () => ({\n  type: ACTIONS.START_GAME,\n});\n","import { useState, useEffect } from 'react';\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\nexport const useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n","import React from 'react';\nimport styled from 'styled-components';\nimport { connect } from 'react-redux';\n\nimport { newBoard, getId } from '../utils/board';\nimport { Tile } from './Tile';\nimport { onTouchMoveAction, onTouchEndAction, setNextSeedAction } from '../actions';\nimport { useWindowDimensions } from '../utils/dimensions';\nimport { BOARD_DIMENSIONS } from '../constants';\n\nconst PlayTiles = styled.div`\n  display: table;\n  border-collapse: separate;\n  border-spacing: 4px;\n  background-color: #3366ff;\n  border-radius: 20px;\n  touch-action: none;\n`;\n\nconst FixedTiles = styled.div`\n  position: fixed;\n  right: 5px;\n  display: table;\n  border-collapse: separate;\n  border-spacing: 4px;\n  background-color: #3366ff;\n  border-radius: 4px;\n`;\n\nconst TileRow = styled.div`\n  display: table-row;\n`;\n\ninterface BoardProps {\n  inPlay: boolean; // redux\n  stateSeed: string; // redux\n  onTouchMove: (e: React.TouchEvent<HTMLDivElement>) => any; // redux\n  onTouchEnd: () => any; // redux\n  setNextSeed: (seed: string) => void; //redux\n}\n\nconst BoardComponent = ({ inPlay, stateSeed, onTouchMove, onTouchEnd, setNextSeed }: BoardProps) => {\n  // Get the seed from url or from state\n  const urlParams = new URLSearchParams(window.location.search);\n  const seedParam = urlParams.get('seed');\n  const seed = seedParam ? seedParam : stateSeed;\n\n  // Get the contents of the board\n  const { board, nextSeed } = newBoard(seed);\n\n  // Calculate the size of the board\n  const { height, width } = useWindowDimensions();\n  // Pick smaller of height and width\n  const min = width < height ? width : height;\n  // if width is smaller, don't add padding\n  const diff = width < height ? 0 : 10;\n  // Get the side of the board\n  const size = min / BOARD_DIMENSIONS - diff;\n\n  // If the timer has expired, move the board to the top right and fix it\n  const Tiles = inPlay ? PlayTiles : FixedTiles;\n\n  // set the next seed. Wasn't sure where to put this so put it here\n  setNextSeed(nextSeed);\n\n  return (\n    <Tiles onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}>\n      {board.map((row, rIndex) => (\n        <TileRow key={rIndex}>\n          {row.map((value, index) => {\n            const id = getId(index, rIndex);\n            return <Tile key={id} tile={{ id, value }} size={size} />;\n          })}\n        </TileRow>\n      ))}\n    </Tiles>\n  );\n};\n\nconst mapStateToProps = ({ inPlay, seed }: { inPlay: boolean; seed: string }) => ({ inPlay, stateSeed: seed });\n\nconst mapDispatchToProps = {\n  onTouchMove: onTouchMoveAction,\n  onTouchEnd: onTouchEndAction,\n  setNextSeed: setNextSeedAction,\n};\n\nexport const Board = connect(mapStateToProps, mapDispatchToProps)(BoardComponent);\n","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { connect } from 'react-redux';\n\nimport { parseTimerProps } from '../utils/timer';\nimport { onTimerEndedAction } from './../actions';\nimport { GAME_TIME } from '../constants';\n\nconst StyledTimer = styled.div`\n  font-family: 'Lucida Console', Monaco, monospace;\n  font-weight: bold;\n  position: fixed;\n  top: 5px;\n  right: 5px;\n`;\n\nconst TimerComponent = ({ timerEnd }: { timerEnd: () => { type: string } }) => {\n  const [seconds, setSeconds] = useState(GAME_TIME);\n  useEffect(() => {\n    let interval = 0;\n    if (seconds > 0) {\n      interval = setInterval(() => {\n        setSeconds((seconds) => seconds - 1);\n      }, 1000);\n    } else if (seconds <= 0) {\n      timerEnd();\n      clearInterval(interval);\n    }\n    return () => clearInterval(interval);\n  }, [seconds, timerEnd]);\n\n  const { display } = parseTimerProps(seconds);\n\n  return <StyledTimer>{display}</StyledTimer>;\n};\n\nconst mapDispatchToProps = { timerEnd: onTimerEndedAction };\n\nexport const Timer = connect(null, mapDispatchToProps)(TimerComponent);\n","export const parseTimerProps = (seconds: number) => {\n  const s = ((seconds % 60) + '').padStart(2, '0');\n  const m = Math.floor(seconds / 60);\n  const display = m + ':' + s;\n  return { display };\n};\n","import { TileType } from '../types';\n\nexport const tilesToString = (selection: Array<TileType>): string => {\n  return selection.map((t) => t.value).join('');\n};\n\nexport const peek = <T>(array: Array<T>): T | null => {\n  if (array.length > 0) {\n    return array[array.length - 1];\n  } else {\n    return null;\n  }\n};\n","import React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { connect } from 'react-redux';\n\nimport { TileType, FoundWords } from '../types';\nimport { tilesToString } from '../utils/tiles';\nimport { newGameAction } from '../actions';\nimport { score } from '../utils/board';\n\nconst Container = styled.div`\n  float: left;\n`;\n\nconst StyledWords = styled.ol``;\n\nconst StyledWord = styled.li<{ cancelled: boolean }>`\n  font-size: 1.2em;\n  margin: 0.5em 0;\n  text-decoration: ${({ cancelled }) => (cancelled ? 'line-through' : 'none')};\n`;\n\n// Fancy button css from\n// https://www.bestcssbuttongenerator.com/#/28\nconst Button = styled.button`\n  margin-bottom: 1em;\n  box-shadow: inset 0px 1px 0px 0px #ffffff;\n  background: linear-gradient(to bottom, #ffffff 5%, #f6f6f6 100%);\n  background-color: #ffffff;\n  border-radius: 6px;\n  border: 1px solid #dcdcdc;\n  display: inline-block;\n  cursor: pointer;\n  color: #666666;\n  font-family: Arial;\n  font-size: 15px;\n  font-weight: bold;\n  padding: 6px 24px;\n  text-decoration: none;\n  text-shadow: 0px 1px 0px #ffffff;\n  :hover {\n    background: linear-gradient(to bottom, #f6f6f6 5%, #ffffff 100%);\n    background-color: #f6f6f6;\n  }\n  :active {\n    position: relative;\n    top: 1px;\n  }\n`;\n\nconst toggle = (\n  actualWords: FoundWords[],\n  setActualWords: React.Dispatch<React.SetStateAction<FoundWords[]>>,\n  index: number\n): void => {\n  // Need to create a copy to force the component to re-render,\n  // since otherwise the state reference does not change\n  const newWords = Array.from(actualWords);\n  newWords[index].cancelled = !newWords[index].cancelled;\n  setActualWords(newWords);\n};\n\nconst tallyText = (total: number): string => {\n  if (total === 0) {\n    return ':( Better luck next time!';\n  } else if (total > 0 && total < 10) {\n    return 'Nice!';\n  } else if (total >= 10 && total < 20) {\n    return 'Oh look! Double digits';\n  } else {\n    return 'Respect!';\n  }\n};\n\nconst TallyComponent = ({\n  words,\n  newGame,\n}: {\n  words: TileType[][];\n  newGame: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n}) => {\n  // the initial state of words as string and default as none are cancelled\n  const initState = words\n    .map((x) => ({ word: tilesToString(x), cancelled: false } as FoundWords))\n    .sort((a, b) => a.word.localeCompare(b.word));\n\n  const [actualWords, setActualWords] = useState(initState);\n  const [scoreVisible, setScoreVisible] = useState(false);\n\n  // This doesn't need to be calculated until we choose to show the score\n  // But okay for now\n  const total = actualWords\n    .filter((x) => !x.cancelled)\n    .map((x) => score(x.word))\n    .reduce((a, b) => a + b, 0);\n\n  return (\n    <Container>\n      {actualWords.length > 0 && (\n        <StyledWords>\n          {actualWords.map((x, i) => (\n            <StyledWord\n              key={`word-${i}`}\n              cancelled={x.cancelled}\n              onClick={() => {\n                if (!scoreVisible) {\n                  toggle(actualWords, setActualWords, i);\n                }\n              }}\n            >\n              {x.word.toLowerCase()}\n            </StyledWord>\n          ))}\n        </StyledWords>\n      )}\n      {scoreVisible ? (\n        <>\n          <div>Score: {total}</div>\n          <div style={{ marginTop: '0.5em' }}>{tallyText(total)}</div>\n          <Button autoFocus style={{ marginTop: '1em' }} onClick={newGame}>\n            New Game\n          </Button>\n        </>\n      ) : (\n        <Button onClick={() => setScoreVisible(true)}>Tally</Button>\n      )}\n    </Container>\n  );\n};\n\nconst mapStateToProps = ({ words }: { words: Array<Array<TileType>> }) => ({ words });\n\nconst mapDispatchToProps = { newGame: newGameAction };\n\nexport const Tally = connect(mapStateToProps, mapDispatchToProps)(TallyComponent);\n","import React, { useState, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { startGameAction } from '../actions';\nimport { SPLASHES } from '../constants';\n\nconst StyledSplash = styled.div`\n  font-size: 2em;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 200px;\n`;\n\nconst SplashComponent = ({ startGame }: { startGame: () => { type: string } }) => {\n  const [text, setText] = useState(SPLASHES.READY);\n  const [seconds, setSeconds] = useState(3);\n\n  useEffect(() => {\n    let interval = 0;\n    if (seconds > 0) {\n      if (seconds === 1.5) {\n        setText(SPLASHES.STEADY);\n      } else if (seconds === 0.5) {\n        setText(SPLASHES.GO);\n      }\n      interval = setInterval(() => {\n        setSeconds((seconds) => seconds - 0.5);\n      }, 500);\n    } else if (seconds <= 0) {\n      clearInterval(interval);\n      startGame();\n    }\n    return () => clearInterval(interval);\n  }, [seconds, startGame, setText, setSeconds]);\n\n  return <StyledSplash>{text}</StyledSplash>;\n};\n\nconst mapDispatchToProps = { startGame: startGameAction };\n\nexport const Splash = connect(null, mapDispatchToProps)(SplashComponent);\n","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { connect } from 'react-redux';\n\nimport { TileType } from '../types';\n\nconst StyledContainer = styled.div`\n  width: 100%;\n  text-align: center;\n`;\n\nconst StyledPopup = styled.span<{ show: boolean }>`\n  padding-left: 10px;\n  padding-right: 10px;\n  background-color: #00ff99;\n  border-radius: 10px;\n  opacity: ${({ show }) => (show ? '1' : '0')};\n  transition: opacity ${({ show }) => (show ? '0' : '1000')}ms linear;\n`;\n\nconst PopupComponent = ({ word, words }: { word: string; words: Array<Array<TileType>> }) => {\n  const [show, setShow] = useState(true);\n  const [display, setDisplay] = useState('Good Luck!');\n\n  useEffect(() => {\n    setShow(true);\n    if (words.length === 0) {\n      setDisplay('Good Luck!');\n    } else {\n      setDisplay(word);\n    }\n    const interval = setInterval(() => {\n      setShow(false);\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [word, words]);\n\n  return (\n    <StyledContainer>\n      <StyledPopup show={show}>{display}</StyledPopup>\n    </StyledContainer>\n  );\n};\n\nconst mapStateToProps = ({ latestWord, words }: { latestWord: string; words: Array<Array<TileType>> }) => ({\n  word: latestWord,\n  words,\n});\n\nexport const Popup = connect(mapStateToProps)(PopupComponent);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { Board } from './Board';\nimport { Timer } from './Timer';\nimport { Tally } from './Tally';\nimport { Splash } from './Splash';\nimport { Popup } from './Popup';\n\nconst GameCenter = styled.div`\n  font-family: Verdana;\n  font-color: black;\n`;\n\nconst GameComponent = ({ displaySplash, inPlay }: { displaySplash: boolean; inPlay: boolean }) => {\n  return (\n    <GameCenter>\n      {displaySplash ? (\n        <Splash />\n      ) : (\n        <>\n          {inPlay ? (\n            <div style={{ marginBottom: '5px' }}>\n              <Popup />\n              <Timer />\n            </div>\n          ) : (\n            <Tally />\n          )}\n          <Board />\n        </>\n      )}\n    </GameCenter>\n  );\n};\n\nconst mapStateToProps = ({ displaySplash, inPlay }: { displaySplash: boolean; inPlay: boolean }) => ({\n  displaySplash,\n  inPlay,\n});\n\nexport const Game = connect(mapStateToProps)(GameComponent);\n","import { TileType, ActionType } from '../types';\nimport { ACTIONS } from '../constants';\nimport { tilesToString, peek } from '../utils/tiles';\nimport { isWordAllowed, isTileAdjacent, isBackTrack, wasPreviouslySelected } from '../utils/board';\n\nconst initialState = {\n  displaySplash: true, //  Whether to show the splash screen or not\n  inPlay: false, // Is the game current in play? Only true when timer is running\n  selecting: false, // Is the selection still being made? Touch is still active?\n  coord: {\n    // the coordinates of the touch\n    x: 0,\n    y: 0,\n  },\n  currentTiles: new Array<TileType>(), // What tile selection is currently in progress\n  latestWord: '', // Latest word\n  words: new Array<Array<TileType>>(), // Successfully selected words so far. I'm keeping this as TileTypes as in the future I may want to animate word selections\n  seed: 'blah', // The starting seed\n  nextSeed: '', // The next seed. I am storing this since I want to make a predictable sequence of new games\n};\n\nexport const reducer = (state = initialState, action: ActionType) => {\n  switch (action.type) {\n    case ACTIONS.TOUCH_START:\n      if (state.inPlay) {\n        return { ...state, selecting: true, coord: action.coord };\n      } else {\n        return state;\n      }\n\n    case ACTIONS.TILE_SELECT:\n      if (state.inPlay) {\n        const last = peek(state.currentTiles);\n        if (last !== null) {\n          // There was at least one selection made earlier\n          // The following checks have to be performed in the exact order\n          if (last.id === action.current.id) {\n            // current tile is the same as last tile, no change\n            return state;\n          } else if (isBackTrack(state.currentTiles, action.current)) {\n            // If user back tracks to remove last selection\n            const currentTiles = Array.from(state.currentTiles);\n            currentTiles.pop();\n            return {\n              ...state,\n              currentTiles,\n            };\n          } else if (wasPreviouslySelected(state.currentTiles, action.current)) {\n            // should not be a previously currentTiles tile\n            return state;\n          } else if (isTileAdjacent(last, action.current)) {\n            // need to check if the new tile is adjacent to the last one\n            const currentTiles = Array.from(state.currentTiles);\n            currentTiles.push(action.current);\n            return {\n              ...state,\n              currentTiles,\n            };\n          } else {\n            // Tile is not allowed\n            return state;\n          }\n        } else {\n          // First tile to be currentTiles, add to stack\n          const currentTiles = Array.from(state.currentTiles);\n          currentTiles.push(action.current);\n          return {\n            ...state,\n            currentTiles,\n          };\n        }\n      } else {\n        return state;\n      }\n\n    case ACTIONS.TOUCH_END:\n      if (state.inPlay) {\n        const word = tilesToString(state.currentTiles);\n        const { words } = state;\n        if (\n          isWordAllowed(\n            word,\n            words.map((x) => tilesToString(x))\n          )\n        ) {\n          words.push(state.currentTiles);\n          return { ...state, selecting: false, currentTiles: new Array<TileType>(), words, latestWord: word };\n        } else {\n          return { ...state, selecting: false, currentTiles: new Array<TileType>() };\n        }\n      } else {\n        return state;\n      }\n\n    case ACTIONS.TIME_END:\n      return { ...state, inPlay: false, selecting: false };\n\n    case ACTIONS.NEW_GAME:\n      var searchParams = new URLSearchParams(window.location.search);\n      searchParams.set('seed', state.nextSeed);\n      window.location.search = searchParams.toString();\n      return { ...initialState, seed: state.nextSeed };\n\n    case ACTIONS.SET_NEXT_SEED:\n      return { ...state, nextSeed: action.seed };\n\n    case ACTIONS.START_GAME:\n      return { ...state, inPlay: true, displaySplash: false };\n\n    default:\n      return state;\n  }\n};\n","import React from 'react';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\n\nimport { Game } from './Game';\nimport { reducer } from './../reducer';\n\nconst store = createStore(reducer);\n\nexport const App = () => {\n  return (\n    <Provider store={store}>\n      <Game />\n    </Provider>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './js/components/App';\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}