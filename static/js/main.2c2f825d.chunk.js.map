{"version":3,"sources":["js/constants/index.ts","js/utils/board.ts","js/components/Tile.tsx","js/actions/index.ts","js/utils/dimensions.ts","js/components/Board.tsx","js/components/Timer.tsx","js/utils/timer.ts","js/utils/tiles.ts","js/components/Tally.tsx","js/components/Splash.tsx","js/components/Popup.tsx","js/components/Game.tsx","js/reducer/index.ts","js/components/App.tsx","index.tsx"],"names":["ACTIONS","SEED","INDEX","COLUMNS","ROWS","UNDERLINED","SPLASHES","randomInt","random","max","Math","floor","nextSeed","result","i","length","newBoard","seed","lowerSeed","toLowerCase","seedrandom","alea","sequence","array","Array","from","BOARD_DIMENSIONS","keys","j","getDieSequence","board","seqIndex","currentDies","dies","dieFace","isWordAllowed","word","existingWords","includes","isTileAdjacent","last","current","toId","id","lastColumnIndex","column","lastRowIndex","row","currentColumnIndex","currentRowIndex","allowedColumn","abs","allowedRow","split","columnValue","rowValue","indexOf","isBackTrack","selection","wasPreviouslySelected","map","x","DieFace","styled","div","inPlay","selected","size","Text","underline","mapDispatchToProps","tileSelect","tile","type","Tile","connect","coord","selecting","currentTiles","value","textRef","createRef","useEffect","el","inColumn","offsetLeft","offsetWidth","inRow","offsetTop","y","offsetHeight","inCurrentTile","ref","getWindowDimensions","window","width","innerWidth","height","innerHeight","PlayTiles","FixedTiles","TileRow","onPointerDown","e","onPointerMove","clientX","clientY","onPointerUp","setNextSeed","Board","stateSeed","seedParam","URLSearchParams","location","search","get","useState","windowDimensions","setWindowDimensions","handleResize","addEventListener","removeEventListener","useWindowDimensions","Tiles","preventDefault","rIndex","key","index","getId","StyledTimer","timerEnd","Timer","seconds","setSeconds","interval","setInterval","clearInterval","display","s","padStart","parseTimerProps","tilesToString","t","join","peek","Container","StyledWords","ol","StyledWord","li","cancelled","Button","button","newGame","Tally","words","initState","sort","a","b","localeCompare","actualWords","setActualWords","scoreVisible","setScoreVisible","total","filter","score","reduce","onClick","newWords","toggle","style","marginTop","tallyText","autoFocus","StyledSplash","startGame","Splash","text","setText","StyledContainer","StyledPopup","span","show","Popup","latestWord","setShow","setDisplay","GameCenter","Game","displaySplash","marginBottom","initialState","store","createStore","state","action","pop","push","searchParams","set","toString","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2c2f825d.chunk.js","sourcesContent":["export const ACTIONS = {\n  SELECT_START: 'SELECT_START',\n  SELECT: 'SELECT',\n  SELECT_END: 'SELECT_END',\n  TILE_SELECT: 'TILE_SELECT',\n  TIME_END: 'TIME_END',\n  NEW_GAME: 'NEW_GAME',\n  SET_NEXT_SEED: 'SET_NEXT_SEED',\n  START_GAME: 'START_GAME',\n};\n\nexport const BOARD_DIMENSIONS = 4;\n\nexport const DOWN_SCALE = 0.4;\n\nexport const GAME_TIME = 120;\n\nexport const SEED = {\n  SIZE: 4,\n  BASE: '0123456789abcdefghijklmnopqrstuvwxyz',\n};\n\n// Using excel/sheets style\nexport const INDEX = {\n  COLUMNS: ['a', 'b', 'c', 'd'],\n  ROWS: ['1', '2', '3', '4'],\n};\n\nexport const UNDERLINED = ['N', 'M', 'W', 'Z'];\n\nexport const SPLASHES = {\n  READY: 'Ready?',\n  STEADY: 'Steady ...',\n  GO: 'GO!',\n};\n","import seedrandom from 'seedrandom';\n\nimport { dies } from './../data/dies.json';\nimport { BOARD_DIMENSIONS, SEED, INDEX } from '../constants';\nimport { TileType } from '../types';\n\ntype DIES = {\n  [key: string]: string[][];\n};\n\n// Returns a random sequence of dies to process\nconst getDieSequence = (random: seedrandom.prng): Array<number> => {\n  // create array populated with numbers 0- DIM*DIM\n  let array = Array.from(Array(BOARD_DIMENSIONS * BOARD_DIMENSIONS).keys());\n  // https://javascript.info/task/shuffle\n  // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = randomInt(random, i + 1);\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n};\n\n// Returns a random number up to specified max\nconst randomInt = (random: seedrandom.prng, max: number): number => {\n  return Math.floor(random() * max);\n};\n\n// Get the next seed (for sharing)\nconst nextSeed = (random: seedrandom.prng): string => {\n  let result = '';\n  for (let i = 0; i < SEED.SIZE; i++) {\n    result += SEED.BASE[randomInt(random, SEED.BASE.length)];\n  }\n  return result;\n};\n\n// Orchestrates creation of random generator and the board\n// Also create the next seed based on the current one\nexport const newBoard = (seed: string) => {\n  const lowerSeed = seed.toLowerCase();\n\n  // https://github.com/davidbau/seedrandom\n  const random = seedrandom.alea(lowerSeed);\n\n  const sequence = getDieSequence(random);\n\n  let board: string[][] = [];\n  let seqIndex = 0;\n\n  const currentDies = (dies as DIES)[`dies${BOARD_DIMENSIONS}`];\n\n  // Populate the 4x4 board sequentially\n  for (var i = 0; i < BOARD_DIMENSIONS; i++) {\n    board[i] = [];\n    for (var j = 0; j < BOARD_DIMENSIONS; j++) {\n      const index = sequence[seqIndex++];\n      const die = currentDies[index];\n      const dieFaceIndex = randomInt(random, 6);\n      const dieFace = die[dieFaceIndex];\n      board[i][j] = dieFace;\n    }\n  }\n  return { board, nextSeed: nextSeed(random) };\n};\n\n// Get the score for the given word\nexport const score = (word: string): number => {\n  switch (word.length) {\n    case 3:\n    case 4:\n      return 1;\n    case 5:\n      return 2;\n    case 6:\n      return 3;\n    case 7:\n      return 5;\n    default:\n      return 11;\n  }\n};\n\n// Word should be valid per Boggle rules\n// And should not have been entered before\nexport const isWordAllowed = (word: string, existingWords: string[]): boolean => {\n  if (word.length < 3 || existingWords.includes(word)) {\n    // Two letter words not allowed\n    // Repeated words not allowed\n    return false;\n  } else {\n    // Word allowed\n    return true;\n  }\n};\n\n// Check to see if the current tile is adjacent to the last one\n// Is there a better looking way to do this?\nexport const isTileAdjacent = (last: TileType, current: TileType): boolean => {\n  const { column: lastColumnIndex, row: lastRowIndex } = toId(last.id);\n  const { column: currentColumnIndex, row: currentRowIndex } = toId(current.id);\n\n  const allowedColumn = Math.abs(lastColumnIndex - currentColumnIndex) <= 1;\n  const allowedRow = Math.abs(lastRowIndex - currentRowIndex) <= 1;\n\n  return allowedColumn && allowedRow;\n};\n\n// helper method to convert a string id to the positional index on the board\nconst toId = (id: string): { column: number; row: number } => {\n  const [columnValue, rowValue] = id.split('');\n\n  const column = INDEX.COLUMNS.indexOf(columnValue);\n  const row = INDEX.ROWS.indexOf(rowValue);\n\n  return { column, row };\n};\n\n// I moved this here so that only one file understands how to construct/deconstruct the key/id\nexport const getId = (column: number, row: number): string => {\n  return INDEX.COLUMNS[column] + INDEX.ROWS[row];\n};\n\n// Is the current tile the one before the latest one\n// This will allow users to back track words\nexport const isBackTrack = (selection: Array<TileType>, current: TileType): boolean => {\n  if (selection.length > 1) {\n    // Has at least two elements\n    const previous = selection[selection.length - 2];\n    return previous.id === current.id;\n  } else {\n    return false;\n  }\n};\n\n// Was the tile previously selected\nexport const wasPreviouslySelected = (selection: Array<TileType>, current: TileType): boolean => {\n  return selection.map((x) => x.id).includes(current.id);\n};\n","import React, { createRef, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { onTileSelectAction } from '../actions';\nimport { TileType } from '../types';\nimport { UNDERLINED, DOWN_SCALE } from '../constants';\n\nconst DieFace = styled.div<{ selected: boolean; inPlay: boolean; size: number }>`\n  cursor: pointer;\n  box-sizing: border-box;\n  text-align: center;\n  vertical-align: middle;\n  display: table-cell;\n  border: 1px solid black;\n  border-radius: ${({ inPlay }) => (inPlay ? 20 : 20 * DOWN_SCALE)}px;\n  background-color: ${({ selected }) => (selected ? 'yellow' : 'white')};\n  width: ${({ inPlay, size }) => (inPlay ? size : size * DOWN_SCALE)}px;\n  height: ${({ inPlay, size }) => (inPlay ? size : size * DOWN_SCALE)}px;\n`;\n\nconst Text = styled.div<{ inPlay: boolean; size: number; underline: boolean }>`\n  cursor: pointer;\n  margin: 0 auto;\n  width: 75%;\n  height: 75%;\n  font-size: ${({ inPlay, size }) => (inPlay ? size - 50 : (size - 50) * DOWN_SCALE)}px;\n  text-decoration: ${({ underline }) => (underline ? 'underline' : 'none')};\n`;\n\ntype TileComponentType = {\n  tile: TileType;\n  size: number;\n} & ReturnType<typeof mapStateToProps> &\n  typeof mapDispatchToProps;\n\n// Check if the touch is over the current tile\nconst inCurrentTile = (el: HTMLDivElement, coord: { x: number; y: number }): boolean => {\n  let inColumn = el.offsetLeft < coord.x && coord.x < el.offsetLeft + el.offsetWidth;\n  let inRow = el.offsetTop < coord.y && coord.y < el.offsetTop + el.offsetHeight;\n  return inColumn && inRow;\n};\n\nconst TileComponent = ({ tile, size, coord, selecting, currentTiles, inPlay, tileSelect }: TileComponentType) => {\n  const underline = UNDERLINED.includes(tile.value);\n\n  // useful for getting co-ordinates of the selection area (Text)\n  const textRef = createRef<HTMLDivElement>();\n\n  const selected = inPlay ? currentTiles.map((x) => x.id).includes(tile.id) : false;\n\n  useEffect(() => {\n    const el = textRef.current;\n    // If user is still selecting and the touch is over the tile\n    if (selecting && el && inCurrentTile(el, coord)) {\n      tileSelect(tile);\n    }\n  }, [coord, selecting, tile, tileSelect, textRef]);\n  return (\n    <DieFace size={size} selected={selected} inPlay={inPlay}>\n      <Text ref={textRef} size={size} underline={underline} inPlay={inPlay}>\n        {tile.value}\n      </Text>\n    </DieFace>\n  );\n};\nconst mapStateToProps = ({\n  coord,\n  selecting,\n  currentTiles,\n  inPlay,\n}: {\n  coord: {\n    x: number;\n    y: number;\n  };\n  selecting: boolean;\n  currentTiles: Array<TileType>;\n  inPlay: boolean;\n}) => ({\n  coord,\n  selecting,\n  currentTiles,\n  inPlay,\n});\n\nconst mapDispatchToProps = { tileSelect: onTileSelectAction };\n\nexport const Tile = connect(mapStateToProps, mapDispatchToProps)(TileComponent);\n","import React from 'react';\n\nimport { ACTIONS } from '../constants';\nimport { TileType } from '../types';\n\nexport const onPointerDownAction = (e: React.PointerEvent<HTMLDivElement>) => ({\n  type: ACTIONS.SELECT_START,\n});\n\nexport const onPointerMoveAction = (e: React.PointerEvent<HTMLDivElement>) => ({\n  type: ACTIONS.SELECT,\n  coord: { x: e.clientX, y: e.clientY },\n});\n\nexport const onPointerUpAction = (e: React.PointerEvent<HTMLDivElement>) => ({\n  type: ACTIONS.SELECT_END,\n});\n\nexport const onTileSelectAction = (tile: TileType) => ({\n  type: ACTIONS.TILE_SELECT,\n  current: tile,\n});\n\nexport const onTimerEndedAction = () => ({\n  type: ACTIONS.TIME_END,\n});\n\nexport const newGameAction = () => ({\n  type: ACTIONS.NEW_GAME,\n});\n\nexport const setNextSeedAction = (seed: string) => ({\n  type: ACTIONS.SET_NEXT_SEED,\n  seed,\n});\n\nexport const startGameAction = () => ({\n  type: ACTIONS.START_GAME,\n});\n","import { useState, useEffect } from 'react';\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\nexport const useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { newBoard, getId } from '../utils/board';\nimport { Tile } from './Tile';\nimport { onPointerDownAction, onPointerMoveAction, onPointerUpAction, setNextSeedAction } from '../actions';\nimport { useWindowDimensions } from '../utils/dimensions';\nimport { BOARD_DIMENSIONS } from '../constants';\n\nconst PlayTiles = styled.div`\n  display: table;\n  margin: auto;\n  border-collapse: separate;\n  border-spacing: 4px;\n  background-color: #3366ff;\n  border-radius: 20px;\n  touch-action: none;\n`;\n\nconst FixedTiles = styled.div`\n  cursor: pointer;\n  position: fixed;\n  top: 30px;\n  right: 5px;\n  display: table;\n  border-collapse: separate;\n  border-spacing: 4px;\n  background-color: #3366ff;\n  border-radius: 4px;\n`;\n\nconst TileRow = styled.div`\n  display: table-row;\n`;\n\ntype BoardProps = ReturnType<typeof mapStateToProps> & typeof mapDispatchToProps;\n\nconst BoardComponent = ({ inPlay, stateSeed, onPointerDown, onPointerMove, onPointerUp, setNextSeed }: BoardProps) => {\n  // Get the seed from url or from state\n  const urlParams = new URLSearchParams(window.location.search);\n  const seedParam = urlParams.get('seed');\n  const seed = seedParam ? seedParam : stateSeed;\n\n  // Get the contents of the board\n  const { board, nextSeed } = newBoard(seed);\n\n  // Calculate the size of the board\n  const { height, width } = useWindowDimensions();\n  // Pick smaller of height and width\n  const min = width < height ? width : height;\n  // if width is smaller, don't add padding\n  const diff = width < height ? 0 : 10;\n  // Get the side of the board\n  const size = min / BOARD_DIMENSIONS - diff;\n\n  // If the timer has expired, move the board to the top right and fix it\n  const Tiles = inPlay ? PlayTiles : FixedTiles;\n\n  // set the next seed. Wasn't sure where to put this so put it here\n  setNextSeed(nextSeed);\n\n  return (\n    <Tiles\n      onPointerDown={onPointerDown}\n      onPointerMove={(e) => {\n        e.preventDefault();\n        onPointerMove(e);\n      }}\n      onPointerUp={onPointerUp}\n    >\n      {board.map((row, rIndex) => (\n        <TileRow key={rIndex}>\n          {row.map((value, index) => {\n            const id = getId(index, rIndex);\n            return <Tile key={id} tile={{ id, value }} size={size} />;\n          })}\n        </TileRow>\n      ))}\n    </Tiles>\n  );\n};\n\nconst mapStateToProps = ({ inPlay, seed }: { inPlay: boolean; seed: string }) => ({ inPlay, stateSeed: seed });\n\nconst mapDispatchToProps = {\n  onPointerDown: onPointerDownAction,\n  onPointerMove: onPointerMoveAction,\n  onPointerUp: onPointerUpAction,\n  setNextSeed: setNextSeedAction,\n};\n\nexport const Board = connect(mapStateToProps, mapDispatchToProps)(BoardComponent);\n","import React, { useState, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { parseTimerProps } from '../utils/timer';\nimport { onTimerEndedAction } from './../actions';\nimport { GAME_TIME } from '../constants';\n\nconst StyledTimer = styled.div`\n  font-family: 'Lucida Console', Monaco, monospace;\n  font-weight: bold;\n  position: fixed;\n  top: 5px;\n  right: 5px;\n`;\n\nconst TimerComponent = ({ timerEnd }: typeof mapDispatchToProps) => {\n  const [seconds, setSeconds] = useState(GAME_TIME);\n  useEffect(() => {\n    let interval = 0;\n    if (seconds > 0) {\n      interval = setInterval(() => {\n        setSeconds((seconds) => seconds - 1);\n      }, 1000);\n    } else if (seconds <= 0) {\n      timerEnd();\n      clearInterval(interval);\n    }\n    return () => clearInterval(interval);\n  }, [seconds, timerEnd]);\n\n  const display = parseTimerProps(seconds);\n\n  return <StyledTimer>{display}</StyledTimer>;\n};\n\nconst mapDispatchToProps = { timerEnd: onTimerEndedAction };\n\nexport const Timer = connect(null, mapDispatchToProps)(TimerComponent);\n","// Converts seconds to minutes:seconds\n// DateTimeFormat is overkill\nexport const parseTimerProps = (seconds: number) => {\n  const s = ((seconds % 60) + '').padStart(2, '0');\n  const m = Math.floor(seconds / 60);\n  const display = m + ':' + s;\n  return display;\n};\n","import { TileType } from '../types';\n\n// Converts an array of TileTypes to a string\nexport const tilesToString = (selection: Array<TileType>): string => {\n  return selection.map((t) => t.value).join('');\n};\n\n// TODO: This is a very generic method, probably belongs in a different file\n// Helper peek method that can tell us the last element in an array without removing it from the array\nexport const peek = <T>(array: Array<T>): T | null => {\n  if (array.length > 0) {\n    return array[array.length - 1];\n  } else {\n    return null;\n  }\n};\n","import React, { useState } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { TileType, FoundWords } from '../types';\nimport { tilesToString } from '../utils/tiles';\nimport { newGameAction } from '../actions';\nimport { score } from '../utils/board';\n\nconst Container = styled.div`\n  float: left;\n`;\n\nconst StyledWords = styled.ol``;\n\nconst StyledWord = styled.li<{ cancelled: boolean }>`\n  cursor: pointer;\n  font-size: 1.2em;\n  margin: 0.5em 0;\n  text-decoration: ${({ cancelled }) => (cancelled ? 'line-through' : 'none')};\n`;\n\n// Fancy button css from\n// https://www.bestcssbuttongenerator.com/#/28\nconst Button = styled.button`\n  margin-bottom: 1em;\n  margin-top: 1em;\n  box-shadow: inset 0px 1px 0px 0px #ffffff;\n  background: linear-gradient(to bottom, #ffffff 5%, #f6f6f6 100%);\n  background-color: #ffffff;\n  border-radius: 6px;\n  border: 1px solid #dcdcdc;\n  display: inline-block;\n  cursor: pointer;\n  color: #666666;\n  font-family: Arial;\n  font-size: 15px;\n  font-weight: bold;\n  padding: 6px 24px;\n  text-decoration: none;\n  text-shadow: 0px 1px 0px #ffffff;\n  :hover {\n    background: linear-gradient(to bottom, #f6f6f6 5%, #ffffff 100%);\n    background-color: #f6f6f6;\n  }\n  :active {\n    position: relative;\n    top: 1px;\n  }\n`;\n\nconst toggle = (\n  actualWords: FoundWords[],\n  setActualWords: React.Dispatch<React.SetStateAction<FoundWords[]>>,\n  index: number\n): void => {\n  // Need to create a copy to force the component to re-render,\n  // since otherwise the state reference does not change\n  const newWords = Array.from(actualWords);\n  newWords[index].cancelled = !newWords[index].cancelled;\n  setActualWords(newWords);\n};\n\nconst tallyText = (total: number): string => {\n  if (total === 0) {\n    return ':( Better luck next time!';\n  } else if (total > 0 && total < 10) {\n    return 'Nice!';\n  } else if (total >= 10 && total < 20) {\n    return 'Oh look! Double digits';\n  } else {\n    return 'Respect!';\n  }\n};\n\ntype TallyType = ReturnType<typeof mapStateToProps> & typeof mapDispatchToProps;\n\nconst TallyComponent = ({ words, newGame }: TallyType) => {\n  // the initial state of words as string and default as none are cancelled\n  const initState = words\n    .map((x) => ({ word: tilesToString(x), cancelled: false } as FoundWords))\n    .sort((a, b) => a.word.localeCompare(b.word));\n\n  const [actualWords, setActualWords] = useState(initState);\n  const [scoreVisible, setScoreVisible] = useState(false);\n\n  // This doesn't need to be calculated until we choose to show the score\n  // But okay for now\n  const total = actualWords\n    .filter((x) => !x.cancelled)\n    .map((x) => score(x.word))\n    .reduce((a, b) => a + b, 0);\n\n  return (\n    <Container>\n      <div>Click on words that are invalid or taken</div>\n      {actualWords.length > 0 && (\n        <StyledWords>\n          {actualWords.map((x, i) => (\n            <StyledWord\n              key={`word-${i}`}\n              cancelled={x.cancelled}\n              onClick={(e) => {\n                e.preventDefault();\n                if (!scoreVisible) {\n                  toggle(actualWords, setActualWords, i);\n                }\n              }}\n            >\n              {x.word.toLowerCase()}\n            </StyledWord>\n          ))}\n        </StyledWords>\n      )}\n      {scoreVisible ? (\n        <>\n          <div style={{ marginTop: '0.5em' }}>Score: {total}</div>\n          <div style={{ marginTop: '0.5em' }}>{tallyText(total)}</div>\n          <Button autoFocus onClick={newGame}>\n            New Game\n          </Button>\n        </>\n      ) : (\n        <Button onClick={() => setScoreVisible(true)}>Tally</Button>\n      )}\n    </Container>\n  );\n};\n\nconst mapStateToProps = ({ words }: { words: Array<Array<TileType>> }) => ({ words });\n\nconst mapDispatchToProps = { newGame: newGameAction };\n\nexport const Tally = connect(mapStateToProps, mapDispatchToProps)(TallyComponent);\n","import React, { useState, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { startGameAction } from '../actions';\nimport { SPLASHES } from '../constants';\n\nconst StyledSplash = styled.div`\n  font-size: 2em;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 200px;\n`;\n\nconst SplashComponent = ({ startGame }: typeof mapDispatchToProps) => {\n  const [text, setText] = useState(SPLASHES.READY);\n  const [seconds, setSeconds] = useState(3);\n\n  useEffect(() => {\n    let interval = 0;\n    if (seconds > 0) {\n      if (seconds === 1.5) {\n        setText(SPLASHES.STEADY);\n      } else if (seconds === 0.5) {\n        setText(SPLASHES.GO);\n      }\n      interval = setInterval(() => {\n        setSeconds((seconds) => seconds - 0.5);\n      }, 500);\n    } else if (seconds <= 0) {\n      clearInterval(interval);\n      startGame();\n    }\n    return () => clearInterval(interval);\n  }, [seconds, startGame, setText, setSeconds]);\n\n  return <StyledSplash>{text}</StyledSplash>;\n};\n\nconst mapDispatchToProps = { startGame: startGameAction };\n\nexport const Splash = connect(null, mapDispatchToProps)(SplashComponent);\n","import React, { useState, useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { TileType } from '../types';\n\nconst StyledContainer = styled.div`\n  width: 100%;\n  text-align: center;\n`;\n\nconst StyledPopup = styled.span<{ show: boolean }>`\n  padding-left: 10px;\n  padding-right: 10px;\n  background-color: #00ff99;\n  border-radius: 10px;\n  opacity: ${({ show }) => (show ? '1' : '0')};\n  transition: opacity ${({ show }) => (show ? '0' : '1000')}ms linear;\n`;\n\nconst PopupComponent = ({ word, words }: ReturnType<typeof mapStateToProps>) => {\n  const [show, setShow] = useState(true);\n  const [display, setDisplay] = useState('Good Luck!');\n\n  useEffect(() => {\n    setShow(true);\n    if (words.length === 0) {\n      setDisplay('Good Luck!');\n    } else {\n      setDisplay(word);\n    }\n    const interval = setInterval(() => {\n      setShow(false);\n    }, 1000);\n    return () => clearInterval(interval);\n  }, [word, words]);\n\n  return (\n    <StyledContainer>\n      <StyledPopup show={show}>{display}</StyledPopup>\n    </StyledContainer>\n  );\n};\n\nconst mapStateToProps = ({ latestWord, words }: { latestWord: string; words: Array<Array<TileType>> }) => ({\n  word: latestWord,\n  words,\n});\n\nexport const Popup = connect(mapStateToProps)(PopupComponent);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport styled from 'styled-components';\n\nimport { Board } from './Board';\nimport { Timer } from './Timer';\nimport { Tally } from './Tally';\nimport { Splash } from './Splash';\nimport { Popup } from './Popup';\n\nconst GameCenter = styled.div`\n  font-family: Verdana;\n  font-color: black;\n`;\n\nconst GameComponent = ({ displaySplash, inPlay }: ReturnType<typeof mapStateToProps>) => {\n  return (\n    <GameCenter>\n      {displaySplash ? (\n        <Splash />\n      ) : (\n        <>\n          {inPlay ? (\n            <div style={{ marginBottom: '5px' }}>\n              <Popup />\n              <Timer />\n            </div>\n          ) : (\n            <Tally />\n          )}\n          <Board />\n        </>\n      )}\n    </GameCenter>\n  );\n};\n\nconst mapStateToProps = ({ displaySplash, inPlay }: { displaySplash: boolean; inPlay: boolean }) => ({\n  displaySplash,\n  inPlay,\n});\n\nexport const Game = connect(mapStateToProps)(GameComponent);\n","import { TileType, ActionType } from '../types';\nimport { ACTIONS } from '../constants';\nimport { tilesToString, peek } from '../utils/tiles';\nimport { isWordAllowed, isTileAdjacent, isBackTrack, wasPreviouslySelected } from '../utils/board';\n\nconst initialState = {\n  displaySplash: true, //  Whether to show the splash screen or not\n  inPlay: false, // Is the game current in play? Only true when timer is running\n  selecting: false, // Is the selection still being made? Touch is still active?\n  coord: {\n    // the coordinates of the touch\n    x: 0,\n    y: 0,\n  },\n  currentTiles: new Array<TileType>(), // What tile selection is currently in progress\n  latestWord: '', // Latest word\n  words: new Array<Array<TileType>>(), // Successfully selected words so far. I'm keeping this as TileTypes as in the future I may want to animate word selections\n  seed: 'blah', // The starting seed\n  nextSeed: '', // The next seed. I am storing this since I want to make a predictable sequence of new games\n};\n\nexport const reducer = (state = initialState, action: ActionType) => {\n  switch (action.type) {\n    case ACTIONS.SELECT_START:\n      if (state.inPlay) {\n        return { ...state, selecting: true };\n      } else {\n        return state;\n      }\n\n    case ACTIONS.SELECT:\n      if (state.inPlay && state.selecting) {\n        return { ...state, coord: action.coord };\n      } else {\n        return state;\n      }\n\n    case ACTIONS.TILE_SELECT:\n      if (state.inPlay) {\n        const last = peek(state.currentTiles);\n        if (last !== null) {\n          // There was at least one selection made earlier\n          // The following checks have to be performed in the exact order\n          if (last.id === action.current!.id) {\n            // current tile is the same as last tile, no change\n            return state;\n          } else if (isBackTrack(state.currentTiles, action.current!)) {\n            // If user back tracks to remove last selection\n            const currentTiles = Array.from(state.currentTiles);\n            currentTiles.pop();\n            return {\n              ...state,\n              currentTiles,\n            };\n          } else if (wasPreviouslySelected(state.currentTiles, action.current!)) {\n            // should not be a previously currentTiles tile\n            return state;\n          } else if (isTileAdjacent(last, action.current!)) {\n            // need to check if the new tile is adjacent to the last one\n            const currentTiles = Array.from(state.currentTiles);\n            currentTiles.push(action.current!);\n            return {\n              ...state,\n              currentTiles,\n            };\n          } else {\n            // Tile is not allowed\n            return state;\n          }\n        } else {\n          // First tile to be currentTiles, add to stack\n          const currentTiles = Array.from(state.currentTiles);\n          currentTiles.push(action.current!);\n          return {\n            ...state,\n            currentTiles,\n          };\n        }\n      } else {\n        return state;\n      }\n\n    case ACTIONS.SELECT_END:\n      if (state.inPlay && state.selecting) {\n        const word = tilesToString(state.currentTiles);\n        const { words } = state;\n        if (\n          isWordAllowed(\n            word,\n            words.map((x) => tilesToString(x))\n          )\n        ) {\n          words.push(state.currentTiles);\n          return {\n            ...state,\n            selecting: false,\n            currentTiles: new Array<TileType>(),\n            words,\n            latestWord: word,\n            coord: { x: 0, y: 0 },\n          };\n        } else {\n          return { ...state, selecting: false, currentTiles: new Array<TileType>(), coord: { x: 0, y: 0 } };\n        }\n      } else {\n        return state;\n      }\n\n    case ACTIONS.TIME_END:\n      return { ...state, inPlay: false, selecting: false };\n\n    case ACTIONS.NEW_GAME:\n      var searchParams = new URLSearchParams(window.location.search);\n      searchParams.set('seed', state.nextSeed);\n      window.location.search = searchParams.toString();\n      return { ...initialState, seed: state.nextSeed };\n\n    case ACTIONS.SET_NEXT_SEED:\n      return { ...state, nextSeed: action.seed };\n\n    case ACTIONS.START_GAME:\n      return { ...state, inPlay: true, displaySplash: false };\n\n    default:\n      return state;\n  }\n};\n","import React from 'react';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\n\nimport { Game } from './Game';\nimport { reducer } from './../reducer';\n\nconst store = createStore(reducer);\n\nexport const App = () => {\n  return (\n    <Provider store={store}>\n      <Game />\n    </Provider>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './js/components/App';\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}